\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{enumerate}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{ifpdf}
\usepackage[usenames]{color}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[titles]{tocloft}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}

\title{Entwurf}
\date{}

\author{Usman Ghani Ahmed \\
Philip Caroli\\
Maximilian Madlung\\ 
Jeremias Mechler\\ 
Fabian Neundorf}

\ifpdf
\DeclareGraphicsExtensions{.pdf}
\else
\DeclareGraphicsExtensions{.eps}
\fi

% Einrückung bei Absätzen
\setlength{\parindent}{0mm}
% Zeilenabstand bei Absätzen
\setlength{\parskip}{2mm}

\begin{document}
 
\vspace{5cm}
\maketitle
\begin{center}
\vspace{3cm}
\huge{Praxis der Softwareentwicklung \\
Gruppe 3 \\[0.5cm]
Entwicklung eines "`Monopoly"'-ähnlichen Spiels \\[0.5cm]
%\includegraphics[height=2cm]{kitlogo_de_rgb}  \\[0.5cm]
WS 2010 / 2011} \\[2cm]
%\textcolor{red}{! DRAFT !}
\end{center}

\newpage

\tableofcontents

\newpage

\section{Architektur}

%EINGABE-VALIDIERUNG
\subsection{Eingabe-Validierung durch Server}
\subsubsection{Motivation}
Bei Multiplayer-Spielen besteht die Gefahr, dass Spieler mit illegitimen Mitteln versuchen, sich Vorteile zu verschaffen ("`cheaten"'). Um dies zu verhindern ist angedacht, auf Serverseite alle von den Clients empfangenen Eingaben auf Richtigkeit zu prüfen, sodass an den Server keine falschen Befehle gesendet werden können. Weiteres Ziel ist das Verhindern von Denial-of-Service-Attacken durch Übersenden von unzulässigen oder sinnlosen Befehlen, die dazu geeignet sind, den reibungslosen Spielablauf zu unterbrechen. 

\subsubsection{Klassen}
\begin{itemize}
\item Checker

Diese Klasse implementiert die Interfaces IServer, bla, blub und enthält eine Instanz der Spielregeln und eine Referenz zum eigentlichen Server und zum Spielzustand. Wird eine der in den Interfaces deklarierten Methoden aufgerufen, so wird mithilfe der Spielregeln und des Spielzustandes überprüft, ob diese Eingabe zum jetzigen Zeitpunkt zulässig ist. Ist dies der Fall, wird sie an den Server weitergeleitet (Fassade), anderenfalls an die Fehlerbehandlungsklasse ErrorHandler übergeben, der über weitere Aktionen entscheidet. Bis auf den Konstruktur, der Referenzen zum Server und zum Spielzustand übernimmt, sind keine öffentlichen Methoden deklariert. 
\item ErrorHandler

Je nach unzulässiger Eingabe sind verschiedene Aktionen möglich. Da in unserer Implementierung die Clients ihre Eingaben mit den Spielregeln auf Zulässigkeit überprüfen, kann davon ausgegangen werden, dass Falscheingaben absichtlich herbeigeführt wurden. Entsprechend könnte eine Reaktion daher das sofortige Entfernen eines Spielers aus dem Spiel sein. Um abgestufte Reaktionen zu ermöglichen, könnte man für jeden Spieler ein Punktekonto mit Verstößen führen, wobei ab einem bestimmten Wert Aktionen gegen den Spieler unternommen werden. Öffentliche Methoden sind keine vorhanden, gespeichert wird lediglich eine Referenz auf den Server sowie ggf. eine Liste mit Punkten für jeden Spieler.
\end{itemize}
\subsubsection{Optionales}
Optional könnte noch eine rudimentäre Client-Server-Authentifizierung über einen geheimen Zahlenwert implementiert werden.


%CLIENT-GRUNDGERUEST
\subsection{Client Grundgerüst}
Das Client Grundgerüst dient als Grundgerüst für den KI- und GUI-Client.
\subsubsection{Schnittstellen}
\begin{itemize}
\item IClient\\
Diese Klasse stellt ein paar minimalen Methoden zur Verfügung um ständiges nachfragen ("`pollen"') zu umgehen.

Methoden:
\begin{itemize}
\item void informTurn(int player) \\
Informiert den Client, dass ein bestimmter Spieler an der Reihe ist.
\item informDiceValues(int[] diceValues) \\
Informiert die Clients über das Würfelergebnis des aktiven Spielers.
\item void informStreetBuy(int playerId) \\
Meldet den Client, dass ein Spieler die Straße gekauft hat, auf der der Spieler stand.
\item void informConstruct(int street) \\
Informiert den Spieler, dass ein Gebäude auf der Straße gebaut wurde.
\item void informDestruct(int street) \\
Informiert über den Abriss eines Gebäudes.
\item void informMortageToogle(int street) \\
Informiert den Client darüber, dass die Straße umgedreht wurde.
\end{itemize}
\item INetworkClient \\
Diese Klasse verwendet den IClient und bietet noch einige spezifische Methoden an, die das Netzwerk betreffen.

Verwendet:
\begin{itemize}
\item IClient
\end{itemize}

Methoden:
\begin{itemize}
\item void messageRecieved(string sender, string text, boolean private) \\
Meldet, dass eine Nachricht an diesen Spieler gesendet wurde.
\item void kicked(int player, int reason, string description) \\
Meldet, dass ein Spieler gekickt wurde.
\end{itemize}
\end{itemize} % Schnittstellen
\subsubsection{Klassen}
\begin{itemize}
\item ClientBase\\
Ist diejenige Klasse, die von den Clients vererbt wird. Diese Klasse ist abstrakt, da sie die Methoden aus "`INetworkClient"' nicht in dieser Klasse implementiert werden.

Verwendet:
\begin{itemize}
\item INetworkClient
\end{itemize}
Attribute:
\begin{itemize}
\item private IServer server \\
Die entsprechende Serverinstanz wird hier abgelegt. Dabei handelt es sich u.A. um das Netzwerk.
\item private RuleSet rules \\
Die Spielregeln werden in dieser Variable gespeichert.
\item protected (?) GameStatus status \\
Speichert den aktuellen Spielzustand, also die Besitzer der Straßen und ähnlichen.
\end{itemize}
Methoden:
\begin{itemize}
\item Folgende Methoden werden für den IServer gewrappt. Dies geschieht um vorher zu testen, ob das Regelwerk den Zug erlaubt.
\begin{itemize}
\item protected void accept()
\item protected void decline()
\item protected void rollDice()
\item protected void endTurn()
\item protected void declareBankruptcy()
\item protected void construct(int street)
\item protected void destruct(int street)
\item protected void toggleMortgage(int street)
\item protected .... (hier die Methoden von IServer) \\
\end{itemize}
\item Folgende Methoden sind Netzwerkspezifisch und liefern eine "`NotNetworkException"', wenn kein Netzwerk existiert.
\begin{itemize}
\item protected void connect(string host) \\
Verbindet sich mit einem Server.
\item protected void sendMessage(string text) \\
Sendet eine Textnachricht an alle Spieler.
\item protected void sendPrivateMessage(string reciever, string text) \\
Sendet eine private Textnachricht an einen spezifischen Spieler.
\end{itemize} % Netzwerk
\item Generelle Methoden
\end{itemize} % Methoden
\end{itemize} % Klassen
\subsubsection{Fehlerklassen}
\begin{itemize}
\item NotNetworkException \\
Wird geworfen, wenn der Client gar keine Netzwerk-Methoden verwenden kann.
\end{itemize} % Fehlerklassen

%KI-CLIENT
\subsection{KI-Client}
\subsubsection{Interfaces}
\begin{itemize}
\item RatingFunction

Das Interface "`RatingFunction"' dient zur Beschreibung der Bewertungsfunktionen. Diese sind als Singletons realisiert und enthalten eine Referenz zum Spielzustand; weiterhin gibt es eine öffentlich aufrufbare Bewertungsfunktion, die ein Argument vom Typ X (entsprechen dem, was zu bewerten gilt) entgegen nimmt und eine Zahl als zurückgibt.
\end{itemize}
\subsubsection{Klassen}
\begin{itemize}
\item KiClient

Diese Klasse erbt vom Client-Grundgerüst und überschreibt bzw. implementiert Methoden, die KI-spezifisch sind.
\item Rater

Der Rater fragt für alle Handlungsmöglichkeiten bei den einzelnen Rating-Funktionen das Ergebnis ab, gewichtet die Teilergebnisse und wählt die Handlungsmöglichkeit mit dem höchsten Ergebnis aus. Er ist als Singleton implementiert und hat eine Methode returnRating, die eine Zahl zurückgibt, die den auszuführenden Spielzug repräsentiert.
\end{itemize}


%GUI-CLIENT
\subsection{GUI-Client}

%Beschreibung
Der GUI-Client baut auf dem Clientgrundger"ust auf bietet eine Graphische Oberfl"ache, um dessen Zustand anzuzeigen und darüber den Server aufzurufen.

\subsubsection{Klassen}

\begin{itemize}
%InteraktionsPopup
\item InteractionPopup
\begin{itemize}
\item Ein graphisches Fenster zum Anzeigen diverser Interaktionsmöglichkeiten
\item Attribute
\begin{itemize}
\item string message
\item boolean acceptEnabled
\item boolean declineEnabled
\end{itemize}
\item Methoden
\begin{itemize}
\item void clearMessage() 
\\löscht die Nachricht und zeigt nichts an
\item void showMessage(string Message, boolean yes, boolean no)
\\Zeigt eine neue Nachricht an, je nachdem sind ""accept"" und ""decline"" aktiviert
\end{itemize}
\end{itemize}

%Street
\item VisibleField
\begin{itemize}
\item Ist eine optische Komponente, die eine Straße anzeigt
\item Attribute
\begin{itemize}
\item string name
\item int price
\item int rent
\item boolean isMortaged
\item Color color
\item int streetID
\item int opticFieldType
\\1 normalgroßes Feld
\\2 normalgroßes Feld, um 90 Grad gedreht
\\3 normalgroßes Feld, um 180 Grad gedreht
\\4 normalgroßes Feld, um 270 Grad gedreht
\\5 großes viereckiges Feld
\item int logicStreetType
\\1 Startfeld
\\2 Gefängnis
\\3 Frei Parken
\\4 gehe in das Gefängnis
\\5 Ereignisfeld
\\6 Gemeinschaftsfeld
\\7 Bahnhof
\\8 Infrastrukturgebäude
\\9 Sondersteuerfelder
\item int[] players
\\welche Spieler befinden sich auf dem Feld?
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean addPlayer(int playerID)
\item boolean removePlayer(int playerID)
\end{itemize}
\end{itemize}

%Chatfenster
\item ChatWindow erweitert \textcolor{red}{JPanel}
\begin{itemize}
\item Eine graphische Komponente, die ein Chatfenster, bestehend aus einem (scrollbaren) Anzeigefenster und einem Texteingabefenster besteht
\item Bei Empfang einer Nachricht wird diese im Anzeigefenster ausgegeben
\item Es können mehrere Nachrichten gleichzeitig angezeigt werden
\item Neue Nachrichten werden unter alten Nachrichten geschrieben
\item Bei Eingabe einer Nachricht in das Texteingabefenster wird die Nachricht an den Server geschickt
\item Attribute
\begin{itemize}
\item string[] messages
\\Eine Liste der n neusten Nachrichten
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean clear()
\\ l"oscht alle Nachrichten
\item boolean write(ChatMessage message)
\\F"ugt der Liste eine neue Nachricht hinzu
\end{itemize}
\end{itemize}

%ChatMessage
\item ChatMessage
\begin{itemize}
\item Beinhaltet alle Elemente einer Chat-Nachricht
\item Attribute
\begin{itemize}
\item Player sender
\\Der Spieler, von dem diese Nachricht gesendet wurde
\item string message
\\Der Text der Nachricht
\item DateTime date
\\Wann die Nachricht empfangen wurde
\end{itemize}
\end{itemize}

%PlayerInfoField
\item PlayerInfoField
\begin{itemize}
\item Eine graphische Komponente, die wesentliche Informationen über einen Spieler anzeigt
\item muss bei Ver"anderungen des Spielerstatus die neuen Daten anzeigen
\item Attribute
\begin{itemize}
\item boolean isOnTurn
\\Ist der derzeitige Spieler an der Reihe?
\item Player player
\\Der Spieler, dessen Informationen angezeigt werden sollen.
\end{itemize}
\item Methoden
\begin{itemize}
\item void actualize()
\\zeigt nun den neuen Spielerzustand an
\end{itemize}
\end{itemize}


\end{itemize}

%SPIELSTATUS
\subsection{Spielstatus}


%Beschreibung
Alle Elemente, die den derzeitigen Zustand des Spiels beschreiben (z.B. Geldst"ande, teilnehmende Spieler) werden im Spielstatus gespeichert. Sowohl der Server als auch der Client besitzen einen Spielstatus.

\subsubsection{Klassen}

\begin{itemize}

%Spielzustand
\item GameState
\begin{itemize}
\item Beinhaltet alle Informationen eines Monopoly-Spiels
\item Attribute
\begin{itemize}
\item int housesOfBank
\item int hotelsOfBank
\item Player[] players
\item Street[] streets
\item Card[] eventCards, communityCards
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean loadGameState(int path)
\item boolean SaveGameState(int path)
\item boolean isValid()
\\ist der derzeit geladene Spielstand fehlerfrei?
\end{itemize}
\end{itemize}

%Player
\item Player
\begin{itemize}
\item Beschreibt einen Spieler aus Sicht des Spielstands
\item Attribute
\begin{itemize}
\item int playerID
\item Color playerColor
\item string playerName
\item int possition
\item int cash
\item Street[] streets
\item int getOutOfJailCardsCount
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean isValid()
\\sind alle Attribute des Spielers g"ultig?
\item void move()
\\ \textcolor{red}{Hinzufügt von Fabian}
\end{itemize}
\end{itemize}

%Feld
\item Field
\begin{itemize}
Dies Klasse beschreibt ein Spielfeld in Monopoly.

Attribute:
\begin{itemize}
\item Player[] playersOnIt
\end{itemize}

Methoden:
\begin{itemize}
\item boolean isValid()
\item void action()
\\ \textcolor{red}{Hinzufügt von Fabian} Führt die Aktion des Feldes aus.
\end{itemize}
\end{itemize}

%Straße
\item Street
\begin{itemize}
Die Klasse Street beschreibt ein besitzbares Feld in Monopoly.

Verwendet:
\begin{itemize}
\item Field
\end{itemize}

Attribute:
\begin{itemize}
\item int ownerPlayerID
\item StreetGroup group
\\Die Stra"sengruppen, der die Stra"se angeh"ort
\item int level
\\wie viele H"auser stehen auf der Stra"se?
\end{itemize}

Methoden:
\begin{itemize}
\item void construct()
\\ \textcolor{red}{Hinzufügt von Fabian}
\end{itemize}
\end{itemize}

%StreetGroup
\item StreetGroup
\begin{itemize}
\item Beinhaltet mehrere Straßen, die regeltechnisch eine Einheit bilden
\item Attribute
\begin{itemize}
\item Color color
\\Die Farbe der Stra"sengruppe (optisch)
\item Street[] streets
\\Liste aller Stra"sen, die der Stra"sengruppe angeh"oren
\end{itemize}
\end{itemize}

%Karte
\item GameCard
\begin{itemize}
\item Eine Spielkarte (Gemeinschafts- oder Ereigniskarte), die in Monopoly ausgeführt werden kann.
\item Attribute
\begin{itemize}
\item string text
\\Der Text, der beim Ausspielen der Karte angezeigt wird
\item GameCardAction action
\\Was wird beim Ausspielen der Karte gemacht?
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean canBeCanceled()
\\Kann die Karte abgelehnt werden?
\item boolean execute(GameState state)
\\Führt die Kartenaktion aus, welche den Spielstatus verändern kann.
\end{itemize}
\end{itemize}

%KartenAktion
\item GameCardAction
\begin{itemize}
\item Kapselung einer Aktion, die beim Ausspielen einer Ereignis- oder Gemeinschaftskarte ausgef"uhrt werden kann
\item Methoden
\begin{itemize}
\item boolean execute(GameState state)
\\f"uhrt eine Aktion aus, welche den Spielstatus verändern kann
\end{itemize}
\end{itemize}
\end{itemize} 

%SERVER
\subsection{Server}

%Beschreibung
Der Server verbindet mehrere Clienten in einem Spiel. Er ist die zentrale Stelle und daf"ur zust"andig Spielzustands"anderungen durch Aufrufe des Clienten an den Server zu registrieren und darauf zu reagieren. Der Server implementiert die Schnittstellen IServer, IServerAuction und IServerTrade. Clienten können entweder direkt vom Server aus gestartet werden, oder "uber das Netzwerk Kontakt aufnehmen. In beiden F"allen passieren die meisten Interaktionen "uber IServer.


\subsubsection{Interfaces}
\begin{itemize}
%IServer
\item IServer
%IServerTrade
\item IServerTrade
%IServerAuction
\item IServerAuction
%ServerToNetwork?
%\item ServerToNetwork
\end{itemize}

\subsubsection{Klassen}
\begin{itemize}
\item MyServer 
\begin{itemize}
\item Implementiert IServer, IServerTrade, IServerAuction
\item Behandelt alle Spielstatusänderungen
\item Clienten können sowohl direkt als auch über das Netzwerk angeschlossen werden
\item Kann über die Konsole angesprochen werden
\item Attribute
\begin{itemize}
\item Ruleset ruleset
\item GameState gamestate
\item Network network
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean startGame(int playerCount) 
\item boolean loadGame(string path)
\item storeGame(int path)
\item loadSettings(int path)
\\l"adt die serverseitigen Einstellungen, zB welches Ruleset verwendet werden soll
\item boolean stopGame()
\\beendet das Spiel, speichert den Spielstand und trennt die Clienten
\item boolean startAIGames(int clientCount, int loops, string path)
\\Startet mehrere aufeinanderfolgende Spiele mit mehreren KI-Clienten. Das Ergebnis wird als Datei gespeichert
\end{itemize}
\end{itemize}
\end{itemize}


\section{Beschreibung der zentralen Abläufe}
\section{Weitere Entwurfdetails}
\section{Abweichungen vom Pflichtenheft}
% besserer Name?
\section{Verantwortlichkeiten und Planung der Implementierungsphase}
\section{Klassendiagramm}
Das Klassendiagramm finden sie als pdf Datei in "`class\_diagram.pdf"'.

\end{document}

\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{enumerate}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{ifpdf}
\usepackage[usenames]{color}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[titles]{tocloft}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}

\title{Entwurf}
\date{}

\author{Usman Ghani Ahmed \\
Philip Caroli\\
Maximilian Madlung\\ 
Jeremias Mechler\\ 
Fabian Neundorf}

\ifpdf
\DeclareGraphicsExtensions{.pdf}
\else
\DeclareGraphicsExtensions{.eps}
\fi

% Einrückung bei Absätzen
\setlength{\parindent}{0mm}
% Zeilenabstand bei Absätzen
\setlength{\parskip}{2mm}

\begin{document}
 
\vspace{5cm}
\maketitle
\begin{center}
\vspace{3cm}
\huge{Praxis der Softwareentwicklung \\
Gruppe 3 \\[0.5cm]
Entwicklung eines "`Monopoly"'-ähnlichen Spiels \\[0.5cm]
%\includegraphics[height=2cm]{kitlogo_de_rgb}  \\[0.5cm]
WS 2010 / 2011} \\[2cm]
%\textcolor{red}{! DRAFT !}
\end{center}

\newpage

\tableofcontents

\newpage

\section{Architektur}

%GEMEINSAME-SCHNITTSTELLE
\subsection{Gemeinsame Schnittstelle}
\subsubsection{Motivation}
Wir haben gemeinsam die Schnittstellen entsprechend unseren Bedürfnissen angepasst. Diese besteht einerseits aus den Interfaces "`IServer"', "`IServerTrade"', "`IServerAuction"' und "`IClient"', sowie aus der Klasse "`Rules"'.
\subsubsection{Schnittstellen}
\begin{itemize}
\item IServer
\begin{itemize}
\item PLATZHALTER
\end{itemize}
\item IServerTrade
\begin{itemize}
\item PLATZHALTER
\end{itemize}
\item IServerAuction
\begin{itemize}
\item PLATZHALTER
\end{itemize}
\item IClient
\begin{itemize}
\item PLATZHALTER
\end{itemize}
\end{itemize} % SCHNITTSTELLEN

\subsubsection{Klassen}
\begin{itemize}
\item Rules \\
Diese Klasse beschreibt einige Grundregeln. Die Eigenschaften sind dabei als öffentliche geschützte Attribute verfügbar.

Attribute:
\begin{itemize}
\item public final int startMoney \\
Dieser Wert gibt das verfügbare Startgeld an.
\item public final int goMoney; \\
In diesem Wert steht, wie viel Geld man bekommen, sobald man über Los kommt.
\item public final boolean doubleMoneyOnGo \\
Dieser Wahrheitswert ist wahr, wenn man doppelt so viel Geld bekommen soll, wenn man auf den Los-Feld zum stehen kommt.
\item public final boolean tradesWithMoney \\
Man kann über diesen Wert bestimmen, ob beim Handeln die "`Ware"' Geld mit benutzt werden darf.
\item public final boolean auctionActive \\
Hiermit kann man Auktionen aktivieren oder deaktivieren.
\item public final boolean moneyOnFreeParking;
Sofern dieser Wert auf wahr steht, bekommt man das Geld aus den Steuertopf sobald man auf das Feld "`Frei Parken"' kommt.
\end{itemize}

Methoden:
\begin{itemize}
\item public Rules(int startMoney, int goMoney, boolean doubleMoneyOnGo, boolean tradesWithMoney, boolean auctionActive, boolean moneyOnFreeParking) \\
Dieser Konstruktor kann einmal die Spielregeln setzen.
\item public Rules() \\
Dieser setzt die Spielregeln auf die Standardregeln von Monopoly:
\begin{enumerate}
\item 30.000 Startgeld
\item 4.000 Geld bei Los
\item kein doppeltes Geld, wenn man auf Los zieht
\item Geld ist beim Handeln erlaubt
\item Auktionen sind erlaubt
\item Man erhält kein Geld aus den Steuertopf, wenn man auf das "`Frei Parken"'-Feld kommt.
\end{enumerate}
\end{itemize}
\end{itemize} % KLASSEN

%CLIENT-GRUNDGERUEST
\subsection{Client Grundgerüst}
Das Client Grundgerüst dient als Grundgerüst für den KI- und GUI-Client.
\subsubsection{Klassen}
\begin{itemize}
\item ClientBase\\
Ist diejenige Klasse, die von den Clients vererbt wird. Diese Klasse ist abstrakt, da die Methoden aus "`IClient"' nicht in dieser Klasse implementiert werden.

Verwendet:
\begin{itemize}
\item IClient
\end{itemize}
Attribute:
\begin{itemize}
\item private IServer server \\
Die entsprechende Serverinstanz wird hier abgelegt. Dabei handelt es sich u.U. um das Netzwerk.
\item protected GameLogic gameLogic \\
Ist eine Referenz auf das aktuelle Spielfeld und den Spielregeln.
\end{itemize}
Methoden:

\begin{itemize}
\item protected void connect(string host, int port) \\
Verbindet sich mit einem Server mithilfe eines Hosts und den entsprechenden Port.
\item protected void connect(IServer server) \\
Setzt einen vorhanden IServer als entsprechendes Server-Objekt.
\item Folgende Methoden werden für den IServer gewrappt. Dies geschieht um vorher zu testen, ob das Regelwerk den Zug erlaubt.
\begin{itemize}
\item protected void accept()
\item protected void decline()
\item protected void rollDice()
\item protected void endTurn()
\item protected void declareBankruptcy()
\item protected void construct(int street)
\item protected void destruct(int street)
\item protected void toggleMortgage(int street)
\item protected void sendMessage(string text)
\item protected void sendPrivateMessage(string reciever, string text)
\end{itemize}
\end{itemize} % Methoden
\end{itemize} % Klassen

%KI-CLIENT
\subsection{KI-Client}
\subsubsection{Interfaces}
\begin{itemize}
\item ValuationFunction

Das Interface "`ValuationFunction"' dient zur Beschreibung der Bewertungsfunktionen, die aus dem Paper von Frayn übernommen wurden. Das Interface stellt allen Funktionen jeweils eine Instanz der Spielregeln und des Spielzustands zur Verfügung. Durch diese können die Bewertungsfunktionen auf alle Informationen zugreifen.
Die statische und öffentliche Methode "`returnValuation"', die von den implementierenden Klassen bereitgestellt wird, gibt die Bewertung des möglichen Spielzugs als Gleitkommaahl zurück.
\end{itemize}
\subsubsection{Klassen}
\begin{itemize}
\item AiClient

Diese Klasse erbt vom Client-Grundgerüst und implementiert die dort vorgegebenen abstrakten Methoden. Die möglichen Spielzüge werden von der Klasse "`Valuator"' bewertet und der beste von AiClient ausgeführt.
\item Valuator

Diese Klasse bewertet die möglichen Spielzüge. Der Spielzug mit der besten Bewertung wird an AiClient zurückgegeben und ausgeführt.
In der Klassenvariable "`weights"' sind die einzelnen, noch zu bestimmenden Gewichte der einzelnen Bewertungsfunktionen gespeichert, die zusammen die Gesamtbewertung ergeben.
\item ValuationParameters

In der Klasse "`ValuationParameters"' werden die von den Bewertungsfunktionen benötigten und noch zu bestimmenden Gewichte gespeichert. Diese sind zur Laufzeit nicht veränderbar.
\item PropertyValuator

Dient zur Bewertung eines kaufbaren Objekts, z.B. einer Straße
\item PropertyGroupValuator

Dient zum Bewerten von Objektgruppen, insbesondere also aller Straßen gleicher Farbe
\item BuildingOnPropertyValuator

Bewertet das Bauen von Häusern, Hotels, etc.
\item PrisonValuator

Befindet sich der KI-Client im Gefängnis, entscheidet diese Klasse, ob Freikaufen rentabel ist. Es kann auch das Kaufen einer "`Gehe aus dem Gefängnis"'-Karte geprüft werden.
\item MortgageValuator

Dient zum Bewerten von Hypotheken
\item CapitalValuator

Es ist laut Paper empfehlenswert, immer eine Mindestmenge Geld zu besitzen.
\end{itemize}


%GUI-CLIENT
\subsection{GUI-Client}

%Beschreibung
Der GUI-Client baut auf dem Clientgrundger"ust auf bietet eine Graphische Oberfl"ache, um dessen Zustand anzuzeigen und darüber den Server aufzurufen.

\subsubsection{Klassen}

\begin{itemize}
%InteraktionsPopup
\item InteractionPopup
\begin{itemize}
\item Ein graphisches Fenster zum Anzeigen diverser Interaktionsmöglichkeiten
\item Attribute
\begin{itemize}
\item string message
\item boolean acceptEnabled
\item boolean declineEnabled
\end{itemize}
\item Methoden
\begin{itemize}
\item void clearMessage() 
\\löscht die Nachricht und zeigt nichts an
\item void showMessage(string Message, boolean yes, boolean no)
\\Zeigt eine neue Nachricht an, je nachdem sind ""accept"" und ""decline"" aktiviert
\end{itemize}
\end{itemize}

%Street
\item VisibleField
\begin{itemize}
\item Ist eine optische Komponente, die eine Straße anzeigt
\item Attribute
\begin{itemize}
\item string name
\item int price
\item int rent
\item boolean isMortaged
\item Color color
\item int streetID
\item int opticFieldType
\\1 normalgroßes Feld
\\2 normalgroßes Feld, um 90 Grad gedreht
\\3 normalgroßes Feld, um 180 Grad gedreht
\\4 normalgroßes Feld, um 270 Grad gedreht
\\5 großes viereckiges Feld
\item int logicStreetType
\\1 Startfeld
\\2 Gefängnis
\\3 Frei Parken
\\4 gehe in das Gefängnis
\\5 Ereignisfeld
\\6 Gemeinschaftsfeld
\\7 Bahnhof
\\8 Infrastrukturgebäude
\\9 Sondersteuerfelder
\item int[] players
\\welche Spieler befinden sich auf dem Feld?
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean addPlayer(int playerID)
\item boolean removePlayer(int playerID)
\end{itemize}
\end{itemize}

%Chatfenster
\item ChatWindow erweitert \textcolor{red}{JPanel}
\begin{itemize}
\item Eine graphische Komponente, die ein Chatfenster, bestehend aus einem (scrollbaren) Anzeigefenster und einem Texteingabefenster besteht
\item Bei Empfang einer Nachricht wird diese im Anzeigefenster ausgegeben
\item Es können mehrere Nachrichten gleichzeitig angezeigt werden
\item Neue Nachrichten werden unter alten Nachrichten geschrieben
\item Bei Eingabe einer Nachricht in das Texteingabefenster wird die Nachricht an den Server geschickt
\item Attribute
\begin{itemize}
\item string[] messages
\\Eine Liste der n neusten Nachrichten
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean clear()
\\ l"oscht alle Nachrichten
\item boolean write(ChatMessage message)
\\F"ugt der Liste eine neue Nachricht hinzu
\end{itemize}
\end{itemize}

%ChatMessage
\item ChatMessage
\begin{itemize}
\item Beinhaltet alle Elemente einer Chat-Nachricht
\item Attribute
\begin{itemize}
\item Player sender
\\Der Spieler, von dem diese Nachricht gesendet wurde
\item string message
\\Der Text der Nachricht
\item DateTime date
\\Wann die Nachricht empfangen wurde
\end{itemize}
\end{itemize}

%PlayerInfoField
\item PlayerInfoField
\begin{itemize}
\item Eine graphische Komponente, die wesentliche Informationen über einen Spieler anzeigt
\item muss bei Ver"anderungen des Spielerstatus die neuen Daten anzeigen
\item Attribute
\begin{itemize}
\item boolean isOnTurn
\\Ist der derzeitige Spieler an der Reihe?
\item Player player
\\Der Spieler, dessen Informationen angezeigt werden sollen.
\end{itemize}
\item Methoden
\begin{itemize}
\item void actualize()
\\zeigt nun den neuen Spielerzustand an
\end{itemize}
\end{itemize}


\end{itemize}

%SPIELSTATUS
\subsection{Spielstatus}


%Beschreibung
Alle Elemente, die den derzeitigen Zustand des Spiels beschreiben (z.B. Geldst"ande, teilnehmende Spieler) werden im Spielstatus gespeichert. Sowohl der Server als auch der Client besitzen einen Spielstatus.

\subsubsection{Klassen}

\begin{itemize}

%Spielzustand
\item GameState
\begin{itemize}
\item Beinhaltet alle Informationen eines Monopoly-Spiels
\item Attribute
\begin{itemize}
\item int housesOfBank
\item int hotelsOfBank
\item Player[] players
\item Street[] streets
\item Card[] eventCards, communityCards
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean loadGameState(int path)
\item boolean SaveGameState(int path)
\item boolean isValid()
\\ist der derzeit geladene Spielstand fehlerfrei?
\end{itemize}
\end{itemize}

%Player
\item Player
\begin{itemize}
\item Beschreibt einen Spieler aus Sicht des Spielstands
\item Attribute
\begin{itemize}
\item int playerID
\item Color playerColor
\item string playerName
\item int possition
\item int cash
\item Street[] streets
\item int getOutOfJailCardsCount
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean isValid()
\\sind alle Attribute des Spielers g"ultig?
\item void move()
\\ \textcolor{red}{Hinzufügt von Fabian}
\end{itemize}
\end{itemize}

%Feld
\item Field
Dies Klasse beschreibt ein Spielfeld in Monopoly.

Attribute:
\begin{itemize}
\item PLATZHALTER
\end{itemize}

Methoden:
\begin{itemize}
\item boolean isValid()
\item void action()
\\ \textcolor{red}{Hinzufügt von Fabian} Führt die Aktion des Feldes aus.

\end{itemize}

%Straße
\item Street
Die Klasse Street beschreibt ein besitzbares Feld in Monopoly.

Verwendet:
\begin{itemize}
\item Field
\end{itemize}

Attribute:
\begin{itemize}
\item int ownerPlayerID
\item StreetGroup group
\\Die Stra"sengruppen, der die Stra"se angeh"ort
\item int level
\\wie viele H"auser stehen auf der Stra"se?
\end{itemize}

Methoden:
\begin{itemize}
\item void construct()
\\ \textcolor{red}{Hinzufügt von Fabian}
\end{itemize}
%Street end

%StreetGroup
\item StreetGroup
\begin{itemize}
\item Beinhaltet mehrere Straßen, die regeltechnisch eine Einheit bilden
\item Attribute
\begin{itemize}
\item Color color
\\Die Farbe der Stra"sengruppe (optisch)
\item Street[] streets
\\Liste aller Stra"sen, die der Stra"sengruppe angeh"oren
\end{itemize}
\end{itemize}

%Karte
\item GameCard
\begin{itemize}
\item Eine Spielkarte (Gemeinschafts- oder Ereigniskarte), die in Monopoly ausgeführt werden kann.
\item Attribute
\begin{itemize}
\item string text
\\Der Text, der beim Ausspielen der Karte angezeigt wird
\item GameCardAction action
\\Was wird beim Ausspielen der Karte gemacht?
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean canBeCanceled()
\\Kann die Karte abgelehnt werden?
\item boolean execute(GameState state)
\\Führt die Kartenaktion aus, welche den Spielstatus verändern kann.
\end{itemize}
\end{itemize}

%KartenAktion
\item GameCardAction
\begin{itemize}
\item Kapselung einer Aktion, die beim Ausspielen einer Ereignis- oder Gemeinschaftskarte ausgef"uhrt werden kann
\item Methoden
\begin{itemize}
\item boolean execute(GameState state)
\\f"uhrt eine Aktion aus, welche den Spielstatus verändern kann
\end{itemize}
\end{itemize}
\end{itemize} 

%SERVER
\subsection{Server}

%Beschreibung
Der Server verbindet mehrere Clienten in einem Spiel. Er ist die zentrale Stelle und daf"ur zust"andig Spielzustands"anderungen durch Aufrufe des Clienten an den Server zu registrieren und darauf zu reagieren. Der Server implementiert die Schnittstellen IServer, IServerAuction und IServerTrade. Clienten können entweder direkt vom Server aus gestartet werden, oder "uber das Netzwerk Kontakt aufnehmen. In beiden F"allen passieren die meisten Interaktionen "uber IServer.


\subsubsection{Interfaces}
\begin{itemize}
%IServer
\item IServer
%IServerTrade
\item IServerTrade
%IServerAuction
\item IServerAuction
%ServerToNetwork?
%\item ServerToNetwork
\end{itemize}

\subsubsection{Klassen}
\begin{itemize}
\item MyServer 
\begin{itemize}
\item Implementiert IServer, IServerTrade, IServerAuction
\item Behandelt alle Spielstatusänderungen
\item Clienten können sowohl direkt als auch über das Netzwerk angeschlossen werden
\item Kann über die Konsole angesprochen werden
\item Attribute
\begin{itemize}
\item Ruleset ruleset
\item GameState gamestate
\item Network network
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean startGame(int playerCount) 
\item boolean loadGame(string path)
\item storeGame(int path)
\item loadSettings(int path)
\\l"adt die serverseitigen Einstellungen, zB welches Ruleset verwendet werden soll
\item boolean stopGame()
\\beendet das Spiel, speichert den Spielstand und trennt die Clienten
\item boolean startAIGames(int clientCount, int loops, string path)
\\Startet mehrere aufeinanderfolgende Spiele mit mehreren KI-Clienten. Das Ergebnis wird als Datei gespeichert
\end{itemize}
\end{itemize}
\end{itemize}

\subsection{Netzwerk}
Das Netzwerk stellt die Verbindung zwischen dem Client und dem Server dar, dabei ist es m"oglich das sich die Spieler in einem lokalen
Netzwerk befinden als auch "uber das Internet in einer anderen Java Virtual Machine arbeiten und am Spiel teilnehmen. Damit der Client Anfragen an den Server schicken kann, die die Ausf"uhrung von Methoden und die R"uckgabe von Ergebnissen beinhalten, verwenden wir den RMI (Remote Method Invocation) Mechanismus , der uns das entfernte Aufrufen von Methoden erlaubt. Die Verbindung von Client und Server wird durch Stellvertreterobjekte(engl. proxies) realisiert. Auf Seite des Clients wird ein Stellvertreter (Stub) des entfernten Objekts (Skeleton) erzeugt, welcher die Daten die "ubermittelt werden kapselt und diese in Form von Nachrichten an den Server "ubermittelt. Die Daten beinhalten unteranderem die zu ausf"uhrende Methode inklusive R"uckgabetyp und alle Parameter.   
  
\subsubsection{Interfaces}
\begin{itemize}
%Remote
\item Remote
\item IServer
\begin{itemize}
\item Hier werden alle Methoden zur Verf"ugung gestellt, die das Server Objekt auf Seite des Clients aufrufen kann
\end{itemize}
\item Serializable
\end{itemize}
\subsubsection{Klassen}


\begin{itemize}
\item UnicastRemoteObject
\begin{itemize}
\item Registriert das zu fernaufrufende Objekt bei der RMI Verwaltung
\item Verwaltet die "Ubertragung des zu fernaufrufenden Objekts zur Java Virtual Machine des Clients.
\end{itemize}
\item ImplBuffer
\item BufferServer
\item RemoteObject
\item Socket
\item ServerSocket
\item Network
\begin {itemize}
\item Attribute
\begin{itemize}
\item ServerSocket server
\item Socket client
\item List <ClientDetails>  client
\end{itemize}
\item Methoden
\begin{itemize}
\item Network(ServerSocket server,Socket client, ServerDetails details) 
\item boolean waitingForClients()
\item boolean cut (int playerID)
\item boolean cut (int playerID, string message)
\item boolean connectionLost(int playerID)
\item boolean sendIServer(MyServer server)
\item ServerDetails getServerDetails()
\item addClient(ClientDetails client)
\end{itemize}
\end{itemize}
\item ServerDetails
\begin {itemize}
\item Attribute
\begin{itemize}
\item String name
\item String ip
\item int connectedPlayers
\item int maxPlayers
\item boolean open
\item int port
\end{itemize}
\item Methoden
\begin{itemize}
\item ServerDetails(ServerSocket server,Socket client, ServerDetails details) 
\end{itemize}
\end{itemize}
\item ClientDetails
\item ClientConnection
\begin{itemize}
\item Implementiert das Interface Serializable
\end{itemize}
\item BufferClient
\end{itemize}

\section{Beschreibung der zentralen Abläufe}
\section{Weitere Entwurfdetails}
\subsection{Kompatibilität mit Client und Server der anderen Gruppe}
Während der Entwurfsphase fanden mehrere Treffen mit einem Verantwortlichen der anderen Gruppe statt. Im Vorfeld wurde versucht, Punkte, an denen es Missverständnisse geben könnte, zu identifizieren. Im Zuge dessen wurden die vorgegebenen Interfaces erweitert und verändert, ein eigenes Interface für den Client definiert. Obwohl beide Gruppen unterschiedliche Entwurfsansätze verfolgen, sollte zumindest nach jetzigem Kenntnisstand einer erfolgreichen Kommunikation nichts im Wege stehen. Beim Abstimmungsprozess wurden zugunsten der Kompatibilität Einschränkungen bei der Erweiterbarkeit hingenommen.
\section{Abweichungen vom Pflichtenheft}
% besserer Name?
\section{Verantwortlichkeiten und Planung der Implementierungsphase}
\section{Klassendiagramm}
Das Klassendiagramm befindet sich als \textit{pdf}-Datei in "`class\_diagram.pdf"'.

\end{document}

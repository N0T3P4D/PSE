\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{enumerate}
\usepackage{ngerman}
\usepackage{graphicx}
\usepackage{ifpdf}
\usepackage[usenames]{color}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[titles]{tocloft}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}

\title{Entwurf}
\date{}

\author{Usman Ghani Ahmed \\
Philip Caroli\\
Maximilian Madlung\\ 
Jeremias Mechler\\ 
Fabian Neundorf}

\ifpdf
\DeclareGraphicsExtensions{.pdf}
\else
\DeclareGraphicsExtensions{.eps}
\fi

% Einrückung bei Absätzen
\setlength{\parindent}{0mm}
% Zeilenabstand bei Absätzen
\setlength{\parskip}{2mm}

\begin{document}
 
\vspace{5cm}
\maketitle
\begin{center}
\vspace{3cm}
\huge{Praxis der Softwareentwicklung \\
Gruppe 3 \\[0.5cm]
Entwicklung eines "`Monopoly"'-ähnlichen Spiels \\[0.5cm]
%\includegraphics[height=2cm]{kitlogo_de_rgb}  \\[0.5cm]
WS 2010 / 2011} \\[2cm]
%\textcolor{red}{! DRAFT !}
\end{center}

\newpage

\tableofcontents

\newpage

\section{Architektur}

%GEMEINSAME-SCHNITTSTELLE
\subsection{Gemeinsame Schnittstelle}
\subsubsection{Motivation}
Wir haben gemeinsam die Schnittstellen entsprechend unseren Bedürfnissen angepasst. Diese besteht einerseits aus den Interfaces "`IServer"', "`IServerTrade"', "`IServerAuction"' und "`IClient"', sowie aus der Klasse "`Rules"'.
\subsubsection{Schnittstellen}
\begin{itemize}
\item IServer \\
Die IServer Schnittstelle dient als gemeinsame Basis für die Clients.

Methoden:
\begin{itemize}
\item int getPlayerPiecePosition(int playerID) \\
Gibt die aktuelle Position des Spielers mit der ID "`playerID"' zurück.
\item int addPlayer(IClient client) \\
Fügt einen Client hinzu.
\item void setPlayerReady(int player) \\
Setzt den Spieler mit der ID "`player"' auf bereit.
\item String getPlayerName(int player) \\
Gibt den Namen eines Spielers zurück.
\item int getPlayerColor(int player) \\
Gibt die Farbe des Spielers zurück.
\item Rules getRules() \\
Gibt den Regelsatz zurück.
\item String getEstateName(int position) \\
Gibt den Namen des Grundstücks auf der in "`position"' definierten Position zurück.
\item int getEstateColorGroup(int position) \\
Gibt die Farbgruppe des Grundstückes zurück. Nicht-negative Werte stehen dabei für die eigentlichen Farbgruppen in der Reihenfolge auf dem Brett. Negative Werte stehen für Sonderfelder:
\begin{description}
\item[-1] Startfeld
\item[-2] Gefängnis
\item[-3] Frei Parken
\item[-4] "`gehe in das Gefängnis"'
\item[-5] Ereignisfelder
\item[-6] Gemeinschaftsfelder
\item[-7] Bahnhöfe
\item[-8] Infrastrukturgebäude
\item[-9] Sondersteuerfelder
\end{description}
Weitere sind benutzerdefiniert.
\item int getEstateHouses(int position) \\
Liefert die Zahl der gebauten Häuser an der gegebenen Position. Ein Hotel wird dabei als die Zahl 5 repräsentiert.
\item int getEstatePrice(int position) \\
Liefert den Kaufpreis des Grundstücks an der gegebeben Position.
\item int getEstateRent(int position, int houses) \\
Liefert die Höhe der Miete für ein Grundstück in der angegebenen Bebauung. Dabei kann das Grundstück sowie die Bebauung gewählt werden.
\item String getGameStatusMessage(int playerID) \\
Liefert die aktuelle Spielmeldung für einen Spieler. Dies können entweder reine Statusmeldungen
oder für den Spielfluss entscheidende Fragen an den Spieler sein, z.B. ob man die Geldstrafe im Gefängnis zahlt oder etwa ob
man ein Grundstück erwerben möchte. In den letzteren Fällen muss dem Server zunächst mit "`accept()"' oder "`decline()"'
geantwortet werden bevor andere Aktionen (z.B. Häuser bauen, Zug beenden) getätigt werden.
\item boolean isMortgaged(int position) \\
Gibt an, ob das gegebene Grundstück mit einer Hypothek belastet ist.
\item int getOwner(int position) \\
Gibt den Eigentümer des Grundstücks an der gegebenen Position an. Falls das Grundstück der Bank gehört, ist das Ergebnis -1.
\item int getDiceValue() \\
Liefert die aktuelle Augensumme.
\item int[] getDiceValues() \\
Liefert die Werte der einzelnen Würfel.
\item int getPlayerCash(int playerID) \\
Liefert das aktuelle Barvermögen eines Spielers. Ein negativer Wert bedeutet dabei, dass der Spieler bankrott ist und aus dem Spiel ausgeschieden ist.
\item int getPlayerOnTurn() \\
Liefert die ID des Spielers, der momentan am Zug ist. Falls das Spiel
momentan nicht läuft, ist das Ergebnis -1.
\item int getNumberOfGetOutOfJailCards(int playerID) \\
Liefert die Zahl der "`Du kommst aus dem Gefängnis frei"'-Karten eines Spielers.
\item int getNumberOfHousesLeft() \\
Liefert die Zahl der noch in der Bank vorhandenen Häuser.
\item int getNumberOfHotelsLeft() \\
Liefert die Zahl der noch in der Bank verbliebenen Hotels.
\item boolean rollDice(int playerID) \\
Rollt die Würfel und bewegt die Figur (falls sie nicht im Gefängnis ist).
Falls dem Spieler eine für den Spielfluss entscheidende Frage gestellt wird, so muss diese
danach mit "`accept()"' oder "`decline()"' beantwortet
werden. Es kann nur einmal am Anfang des Zuges gewürfelt werden (bzw. dreimal im Gefängnis).
\item boolean accept(int playerID) \\
Gibt eine positive Antwort auf eine spielentscheidende Frage des Servers.
Kann nur getätigt werden, wenn die aktuelle Statusmeldung eine solche
Frage ist.
\item boolean decline(int playerID) \\
Gibt eine negative Antwort auf eine spielentscheidende Frage des Servers.
Kann nur getätigt werden, wenn die aktuelle Statusmeldung eine solche
Frage ist.
\item boolean endTurn(int playerID) \\
Beendet den aktuellen Zug. Kann nur getätigt werden, wenn gewürfelt und
alle spielentscheidenen Fragen beantwortet wurden.
\item boolean declareBankruptcy(int playerID) \\
Erklärt Bankrott. Setzt das Barvermögen des jeweiligen Spielers auf einen negativen Wert.
\item boolean construct(int playerID, int position) \\
Baut "`ein"' Haus auf das angegebene Grundstück. Kann nur getätigt
werden, wenn die Bedingungen dafür erfüllt sind.
\item boolean deconstruct(int playerID, int position)
Löst "`ein"' Haus auf dem angegebenen Grundstück auf. Kann nur
getätigt werden, wenn die Bedingungen dafür erfüllt sind.
\item boolean toggleMortgage(int playerID, int position)
Nimmt eine Hypothek auf das angegebene Grundstück auf oder zahlt diese
zurück.
\item void sendMessage(String text)
Sendet eine öffentliche Nachricht an alle.
\item void sendPrivateMessage(String text, int reciever)
Sendet eine private Nachricht an den entsprechenden Empfänger.
\end{itemize}
%IServerTrade

\item IServerTrade
Eine Erweiterung der IServer-Schnittstelle, sodass auch Auktionen abgewickelt werden k"onnen

Methoden:
\begin{itemize}
\item int getAuctionState()
Gibt den derzeitigen Stand der Auktion an
\begin{description}
\item[-1] keine Auktion l"auft
\item[0] Auktion l"auft
\item[1] ""Zum Ersten""
\item[2] ""Zum Zweiten""
\item[3] Auktion abgeschlossen, Daten sind noch abrufbar
\end{description}
\item int getAuctionedEstate()
Gibt die Position des Grundst"uck zur"uck, das versteigert wird
\item int getHighestBid()
Gibt das bisher h"ochste Gebot zur"uck
\item int getHighestBidder()
Gibt den bisher h"ochsten Bieter zur"uck
\item boolean placeBid(int playerID, int amount)
Gibt ein Gebot in der H"ohe amount des Spielers playerID ab
\end{itemize}
\item IServerAuction
Erweiterung der Schnittstelle IServer, sodass gehandelt werden kann

Methoden:
\begin{itemize}
\item boolean initTrade(int actingPlayer, int partnerPlayer)
Startet einen Handel zwischen actingPlayer und partnerPlayer
\item int getTradeState()
Gibt den Zustand des Handels an
\begin{description}
\item[-1] Dezeit kein Handel
\item[0] Handelssitzung l"auft, bisher noch kein Angebot
\item[1]Handelssitzung l"auft, Angebot liegt vor, noch keine Entscheidung
\item[2] Handelsangebot wurde abgewiesen
\item[3] Handelsangebot wurde angenommen
\end{description}
\item int getPartner()
Liefert den Handelspartner
\item boolean offerCash(int playerID, int cash)
Bietet Geld
\item offerGetOutOfJailCard(int playerID)
Bietet eine ""Komme aus dem Gef"angnis frei Karte"" an
\item boolean offerEstate(int playerID, int position)
Bietet ein Grundst"uck an
\item boolean requireCash(int playerID, int position)
Fordert Geld
\item boolean requireGetOutOfJailCard(int playerID)
Fordert eine ""Komme aus dem Gef"angnis frei Karte""
\item requireEstate(int playerID, int position)
Fordert ein Grundst"uck
\item int[] getOfferedEstates
Liefert alle angebotenen Grundst"ucke
\item int getOfferedCash()
Liefert das angebotene Geld
\item getNumberOfOfferedGetOutOfJailCards()
Liefert die Anzahl angebotener ""Komme aus dem Gef"angnis frei Karten""
\item int[] getRequiredEstates()
Liefert alle angeforderten Grundst"ucke
\item int getRequiredCash()
Liefert das geforderte Geld
\item int getNumberOfRequiredGetOutOfJailCards()
Liefert die Anzahl geforderter ""Komme aus dem Gef"angnis frei Karten""
\item boolean cancelTrade(int playerID)
Bricht die aktuelle Handelssitzung ab
\item boolean proposeTrade(int playerID)
Schl"agt einen Handel vor, zuvor wurde mit offer/require Estate/Cash/GetOutOfJailCard festgelegt, um was gehandelt wurde
\end{itemize}
\item IClient
Wurde gemeinsam mit der anderen Gruppe entwickelt. Dieses Interface dient dazu, die Kommunikation von Serverseite aus zu den Clienten zu erm"oglichen

Methoden:
\begin{itemize}
\item string getName()
Liefert den Namen des Spielers
\item string getLanguage()
Gibt die Sprache des Spielers zur"uck, zB ""de"" f"ur deutsch, ""fr"" f"ur Franz"osisch
\item informStartGame(int numberOfPlayers)
Informiert den Clienten, dass das Spiel beginnt
\item void informTurn()
Informiert den Clienten, dass er an der Reihe ist
\item void informDiceValues(int[] diceValues, int playerID)
Informiert den Clienten, dass ein neuer W"urfelwurf vorliegt
\item void informCashChange(int playerID, int cashChange)
Informiert den Clienten, dass sich ein Kontostand ge"andert hat
\item void informStreetBuy(int playerID)
Informiert den Clienten, dass ein Spieler eine Stra"se gekauft hat
\item void informConstruct(int position)
Informiert den Clienten, dass eine Stra"se ausgebaut wurde
\item void informDestruct(int position)
Informiert den Clienten, dass eine Stra"se um einen Rang verringert wurde
\item void informMortageToogle(int position)
Informiert den Clienten, dass eine Hypothek aufgenommen/abbezahlt wurde
\item void informCardPull(String text, boolean communityCard)
Informiert den Clienten, dass er eine Gemeinschafts- oder Ereigniskarte gezogen hat
\item void informBankruptcy()
Informiert den Clienten, dass der aktuelle Spieler bankrott ist
\item void informMessage(string text, int sender, boolean privateMessage)
Informiert den Clienten, dass er eine neue Nachricht empfangen hat
\end{itemize}
\end{itemize} % SCHNITTSTELLEN

\subsubsection{Klassen}
\begin{itemize}
\item Rules \\
Diese Klasse beschreibt einige Grundregeln. Die Eigenschaften sind dabei als öffentliche geschützte Attribute verfügbar.

Attribute:
\begin{itemize}
\item public final int startMoney \\
Dieser Wert gibt das verfügbare Startgeld an.
\item public final int goMoney; \\
In diesem Wert steht, wie viel Geld man bekommen, sobald man über Los kommt.
\item public final boolean doubleMoneyOnGo \\
Dieser Wahrheitswert ist wahr, wenn der Spieler doppelt so viel Geld bekommen soll, wenn er auf den Los-Feld zum stehen kommt.
\item public final boolean tradesWithMoney \\
Über diesen Wert kann bestimmt werden, ob beim Handeln die "`Ware"' Geld mitbenutzt werden darf.
\item public final boolean auctionActive \\
Hiermit kann man Auktionen aktivieren oder deaktivieren.
\item public final boolean moneyOnFreeParking;
Sofern dieser Wert auf wahr steht, bekommt der Spieler das Geld aus den Steuertopf sobald dieser auf das Feld "`Frei Parken"' kommt.
\end{itemize}

Methoden:
\begin{itemize}
\item public Rules(int startMoney, int goMoney, boolean doubleMoneyOnGo, boolean tradesWithMoney, boolean auctionActive, boolean moneyOnFreeParking) \\
Dieser Konstruktor kann einmal die Spielregeln setzen.
\item public Rules() \\
Dieser setzt die Spielregeln auf die Standardregeln von Monopoly:
\begin{enumerate}
\item 30.000 Startgeld
\item 4.000 Geld bei Los
\item kein doppeltes Geld, wenn man auf Los zieht
\item Geld ist beim Handeln erlaubt
\item Auktionen sind erlaubt
\item Man erhält kein Geld aus den Steuertopf, wenn man auf das "`Frei Parken"'-Feld kommt.
\end{enumerate}
\end{itemize}
\end{itemize} % KLASSEN

%CLIENT-GRUNDGERUEST
\subsection{Client Grundgerüst}
Das Client Grundgerüst dient als Grundgerüst für den KI- und GUI-Client.
\subsubsection{Klassen}
\begin{itemize}
\item ClientBase\\
Ist diejenige Klasse, die von den Clients vererbt wird. Diese Klasse ist abstrakt, da die Methoden aus "`IClient"' nicht in dieser Klasse implementiert werden.

Verwendet:
\begin{itemize}
\item IClient
\end{itemize}
Attribute:
\begin{itemize}
\item private IServer server \\
Die entsprechende Serverinstanz wird hier abgelegt. Dabei handelt es sich u.U. um das Netzwerk.
\item protected GameLogic gameLogic \\
Ist eine Referenz auf das aktuelle Spielfeld und den Spielregeln.
\end{itemize}
Methoden:

\begin{itemize}
\item protected void connect(string host, int port) \\
Verbindet sich mit einem Server mithilfe eines Hosts und den entsprechenden Port.
\item protected void connect(IServer server) \\
Setzt einen vorhanden IServer als entsprechendes Server-Objekt.
\item Folgende Methoden werden für den IServer gewrappt. Dies geschieht um vorher zu testen, ob das Regelwerk den Zug erlaubt.
\begin{itemize}
\item protected void accept()
\item protected void decline()
\item protected void rollDice()
\item protected void endTurn()
\item protected void declareBankruptcy()
\item protected void construct(int street)
\item protected void destruct(int street)
\item protected void toggleMortgage(int street)
\item protected void sendMessage(string text)
\item protected void sendPrivateMessage(string reciever, string text)
\end{itemize}
\end{itemize} % Methoden
\end{itemize} % Klassen

%KI-CLIENT
\subsection{KI-Client}
\subsubsection{Interfaces}
\begin{itemize}
\item ValuationFunction

Das Interface "`ValuationFunction"' dient zur Beschreibung der Bewertungsfunktionen, die aus dem Paper von Frayn übernommen wurden. Das Interface stellt allen Funktionen jeweils eine Instanz der Spielregeln und des Spielzustands zur Verfügung. Durch diese können die Bewertungsfunktionen auf alle Informationen zugreifen.
Die statische und öffentliche Methode "`returnValuation"', die von den implementierenden Klassen bereitgestellt wird, gibt die Bewertung des möglichen Spielzugs als Gleitkommaahl zurück.
\end{itemize}
\subsubsection{Klassen}
\begin{itemize}
\item AiClient

Diese Klasse erbt vom Client-Grundgerüst und implementiert die dort vorgegebenen abstrakten Methoden. Die möglichen Spielzüge werden von der Klasse "`Valuator"' bewertet und der beste von AiClient ausgeführt.
\item Valuator

Diese Klasse bewertet die möglichen Spielzüge. Der Spielzug mit der besten Bewertung wird an AiClient zurückgegeben und ausgeführt.
In der Klassenvariable "`weights"' sind die einzelnen, noch zu bestimmenden Gewichte der einzelnen Bewertungsfunktionen gespeichert, die zusammen die Gesamtbewertung ergeben.
\item ValuationParameters

In der Klasse "`ValuationParameters"' werden die von den Bewertungsfunktionen benötigten und noch zu bestimmenden Gewichte gespeichert. Diese sind zur Laufzeit nicht veränderbar.
\item PropertyValuator

Dient zur Bewertung eines kaufbaren Objekts, z.B. einer Straße
\item PropertyGroupValuator

Dient zum Bewerten von Objektgruppen, insbesondere also aller Straßen gleicher Farbe
\item BuildingOnPropertyValuator

Bewertet das Bauen von Häusern, Hotels, etc.
\item PrisonValuator

Befindet sich der KI-Client im Gefängnis, entscheidet diese Klasse, ob Freikaufen rentabel ist. Es kann auch das Kaufen einer "`Gehe aus dem Gefängnis"'-Karte geprüft werden.
\item MortgageValuator

Dient zum Bewerten von Hypotheken
\item CapitalValuator

Es ist laut Paper empfehlenswert, immer eine Mindestmenge Geld zu besitzen.
\end{itemize}


%GUI-CLIENT
\subsection{GUI-Client}

%Beschreibung
Der GUI-Client baut auf dem Clientgrundger"ust auf bietet eine Graphische Oberfl"ache, um dessen Zustand anzuzeigen und darüber den Server aufzurufen.

\subsubsection{Klassen}

\begin{itemize}
%InteraktionsPopup
\item InteractionPopup
\begin{itemize}
\item Ein graphisches Fenster zum Anzeigen diverser Interaktionsmöglichkeiten
\item Attribute
\begin{itemize}
\item string message
\item boolean acceptEnabled
\item boolean declineEnabled
\end{itemize}
\item Methoden
\begin{itemize}
\item void clearMessage() 
\\löscht die Nachricht und zeigt nichts an
\item void showMessage(string Message, boolean yes, boolean no)
\\Zeigt eine neue Nachricht an, je nachdem sind "`accept"' und "`decline"' aktiviert
\end{itemize}
\end{itemize}

%Street
\item VisibleField
\begin{itemize}
\item Ist eine optische Komponente, die eine Straße anzeigt
\item Attribute
\begin{itemize}
\item string name
\item int price
\item int rent
\item boolean isMortaged
\item Color color
\item int streetID
\item int opticFieldType
\\1 normalgroßes Feld
\\2 normalgroßes Feld, um 90 Grad gedreht
\\3 normalgroßes Feld, um 180 Grad gedreht
\\4 normalgroßes Feld, um 270 Grad gedreht
\\5 großes viereckiges Feld
\item int logicStreetType
\\1 Startfeld
\\2 Gefängnis
\\3 Frei Parken
\\4 gehe in das Gefängnis
\\5 Ereignisfeld
\\6 Gemeinschaftsfeld
\\7 Bahnhof
\\8 Infrastrukturgebäude
\\9 Sondersteuerfelder
\item int[] players
\\welche Spieler befinden sich auf dem Feld?
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean addPlayer(int playerID)
\item boolean removePlayer(int playerID)
\end{itemize}
\end{itemize}

%Chatfenster
\item ChatWindow erweitert \textcolor{red}{JPanel}
\begin{itemize}
\item Eine graphische Komponente, die ein Chatfenster, bestehend aus einem (scrollbaren) Anzeigefenster und einem Texteingabefenster besteht
\item Bei Empfang einer Nachricht wird diese im Anzeigefenster ausgegeben
\item Es können mehrere Nachrichten gleichzeitig angezeigt werden
\item Neue Nachrichten werden unter alten Nachrichten geschrieben
\item Bei Eingabe einer Nachricht in das Texteingabefenster wird die Nachricht an den Server geschickt
\item Attribute
\begin{itemize}
\item string[] messages
\\Eine Liste der n neusten Nachrichten
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean clear()
\\ l"oscht alle Nachrichten
\item boolean write(ChatMessage message)
\\F"ugt der Liste eine neue Nachricht hinzu
\end{itemize}
\end{itemize}

%ChatMessage
\item ChatMessage
\begin{itemize}
\item Beinhaltet alle Elemente einer Chat-Nachricht
\item Attribute
\begin{itemize}
\item Player sender
\\Der Spieler, von dem diese Nachricht gesendet wurde
\item string message
\\Der Text der Nachricht
\item DateTime date
\\Wann die Nachricht empfangen wurde
\end{itemize}
\end{itemize}

%PlayerInfoField
\item PlayerInfoField
\begin{itemize}
\item Eine graphische Komponente, die wesentliche Informationen über einen Spieler anzeigt
\item muss bei Ver"anderungen des Spielerstatus die neuen Daten anzeigen
\item Attribute
\begin{itemize}
\item boolean isOnTurn
\\Ist der derzeitige Spieler an der Reihe?
\item Player player
\\Der Spieler, dessen Informationen angezeigt werden sollen.
\end{itemize}
\item Methoden
\begin{itemize}
\item void actualize()
\\zeigt nun den neuen Spielerzustand an
\end{itemize}
\end{itemize}


\end{itemize}


%LOGIKREGELNZUSTAND
\subsection{LogikRegelnZustand}

%Beschreibung
Dieses Paket enthält den Zustand, sowie die Regeln und die Logik um Eingaben zu validieren, Informationen zu erlangen oder einzufügen.


%GameLogic
\begin{itemize}
\item GameLogic \\
Beinhaltet den Inhalt des Pakets und ist die Kontaktstelle nach außen.

Methoden:
\begin{itemize}
\item boolean newGame()
\\Startet ein neues Spiel, lädt die Regeln und erstellt einen Zustand.
\item boolean addPlayer(int playerId, String playerName, int playerCash)
\\Fügt dem Spiel einen Spieler hinzu und gibt an ob es geklappt hat, schließlich dürfen laut Monopolyregeln z.B. nur maximal 8 Spieler spielen.
\item void addMessage(int messageId, int playerId, String text)
\\Fügt dem Chat eine Nachricht hinzu.
\item void addRoll(int player, int[] dices)
\\Fügt einen neuen Wurf dem Status hinzu
\item void startGame()
\\Startet das Spiel (Also aus der GUI aus gesehen vom Warteraum aufs Spielbrett)
\item void movePlayer(int player, int street)
\\Bewegt einen Spieler zu einer Straße
\item void buyStreet(int player, int street)
\\Gibt dem Spieler eine Straße
\item void upgradeStreet(int player, int street, int level)
\\Setzt eine Straße auf ein neues Level
\item void useCard(int player, int card)
\\Benutzt für den Spieler eine Karte
\item void exitJail(int player)
\\Befreit den Spieler aus dem Gefängnis :)
\item GameState getGameState()
\\Setzt einen neuen Spielstatus

\end{itemize} % end methoden
%end GameState

%GameRules
\item GameRules \\
Beinhaltet die Regeln des Spiels.

Methoden:
\begin{itemize}
\item void setGameState(GameState gameState)
\\Setzt den Gamestate
\item boolean movementValid(int player, int field)
\\Ist der Spielzug ok?
\item boolean buyingValid(int player, int street)
\\Ist dieser Kauf ok?
\item boolean cardValid(int player, int card)
\\Ist das Verwenden der Karte von diesem Spieler ok?
\item boolean upgradeValid(int player, int street, int level)
\\Ist das Upgraden dieser Straße ok?
\item boolean playerHasCash(int player, int cash)
\\hat der Spieler das gewollte Geld?
\end{itemize} % end methoden
%end GameRules
\end{itemize} % end klassen

%SPIELSTATUS
\subsection{Spielstatus}


%Beschreibung
Alle Elemente, die den derzeitigen Zustand des Spiels beschreiben (z.B. Geldst"ande, teilnehmende Spieler) werden im Spielstatus gespeichert. Sowohl der Server als auch der Client besitzen einen Spielstatus.

\subsubsection{Klassen}

\begin{itemize}

%Spielzustand
\item GameState
\begin{itemize}
\item Bietet Objekt-Zugriff auf alle Karten, Felder, Spieler, den Chat und bietet die Möglichkeit, Spielstände zu laden und zu speichern.
\item Attribute

keine
\item Methoden
\begin{itemize}
\item getPlayer()

Gibt eine Menge mit Referenzen auf alle Spieler zurück
\item GameField getField()

Gibt eine Referenz auf das Spielfeld zurück
\item getCard()

Gibt eine Menge mit Referenzen auf alle Karten zurück
\item Chat getChat()

Gibt eine Referenz auf das Chat-Objekt zurück
\item boolean loadGameState(String path)

Lädt den unter \textit{path} abgelegten Spielstand. Ist das Laden erfolgreich, wird \textit{true} zurückgegeben, sonst \textit{false}
\item boolean saveGameState(String path)

Speichert den Spielstand nach \textit{path}. Ist das Speichern erfolgreich, wird \textit{true} zurückgegeben, sonst \textit{false}
\end{itemize}
\end{itemize}

%Player
\item Player
\begin{itemize}
\item Beschreibt einen Spieler aus Sicht des Spielstands
\item Attribute
\begin{itemize}
\item int id

Die eindeutige Spieler-ID
\item Color color

Die Farbe des Spielers
\item String name

Der Name des Spielers
\item int possition

Die aktuelle Position des Spielers
\item int cash

Der aktuelle Geldbetrag des Spielers
\item int getOutOfJailCardsCount

Die Anzahl der "`Gehe aus dem Gefängnis"'-Karten des Spielers
\end{itemize}
\item Methoden
\begin{itemize}
\item Spieler(int id, int cash, String name)

Konstruktur. Für die Argumente siehe \textit{Attribute}
\item void addCash(int cash)

Fügt dem Spieler den Geldbetrag \textit{cash} hinzu.
\end{itemize}
\end{itemize}

%Feld
\item GameField
Dies Klasse beschreibt ein Spielfeld in Monopoly.

Attribute:
\begin{itemize}
\item int id

Eindeutige ID des Spielfeldes
\item int ownedByPlayer

ID des Players. Ist die ID $<= 0$, so gehört das Feld der Bank.
\item boolean turnedAround

Gibt an, ob eine Hypothek auf dem Feld ist.

\end{itemize}

Methoden:
\begin{itemize}
\item int getId()
\item boolean buy()
\item boolean turnAround()
\item boolean isTurnedAround()
\item boolean isValid()
\item void action()
\\ \textcolor{red}{Hinzufügt von Fabian} Führt die Aktion des Feldes aus.

\end{itemize}

%Straße
\item Street
Die Klasse Street beschreibt ein besitzbares Feld in Monopoly.

Verwendet:
\begin{itemize}
\item Field
\end{itemize}

Attribute:
\begin{itemize}
\item int ownerPlayerID
\item StreetGroup group
\\Die Stra"sengruppen, der die Stra"se angeh"ort
\item int buildLevel
\\wie viele H"auser stehen auf der Stra"se?
\end{itemize}

Methoden:
\begin{itemize}
\item void construct()
\\ \textcolor{red}{Hinzufügt von Fabian}
\item int getLevel()
\item int upgrade(int level)
\end{itemize}
%Street end



\end{itemize}

%SPIELREGELN
\subsection{Spielregeln}


%Beschreibung
Die Regeln des Spiels

\subsubsection{Klassen}

\begin{itemize}
%CardRule
\item CardRule
\begin{itemize}
\item Beinhaltet die Karten und ihre Regeln, sowie die Eigenschaften welche für diese Karte unabhängig vom Spielstatus sind.

\item Methoden
\begin{itemize}
\item int getId()
\\Die Id der Karte
\item string getName()
\\der Name der Karte
\item Image getImage()
\\das Bild der Karte
\item void execute(int player)
\\Führt die Aktion dieser Karte aus
\end{itemize}
\end{itemize}

%CardAction
\item CardAction
\begin{itemize}
\item Kapselung einer Aktion, die beim Ausspielen einer Ereignis- oder Gemeinschaftskarte ausgef"uhrt werden kann.

\item Methoden
\begin{itemize}
\item void execute(int player,int[] argument)
\\Diese Aktion wird von einer Karte mit dieser Regel ausgeführt
\end{itemize}
\end{itemize}

%FieldRule
\item FieldRule
\begin{itemize}
\item Beinhaltet die Straßeninformationen die nicht durch den Spielstatus verändert werden.
\item Methoden
\begin{itemize}
\item int getId()
\\Die Id des Feldes
\item String getName()
\\Der Name des Feldes
\item int getPosition()
\\Die Position des Feldes
\item Color getColor()
\\Die Farbe der Stra"sengruppe (optisch) und damit auch die Zuordnung zu einer Gruppe
\item int getPrice()
\\Die Kosten des Feldes
\item int getLevelPayment(int level)
\\Die Mietkosten je nach Gebäudelevel
\item Image getImage()
\\Das Bild des Feldes
\item void execute(int player)
\\Die Aktion wenn eine Spieler auf diesem Feld landet
\item void passTrough(int player)
\\Die Aktion wenn eine Spieler über dieses Feld marschiert oder auf ihm landet
\end{itemize}
\end{itemize}
\end{itemize}

%SERVER
\subsection{Server}

%Beschreibung
Der Server verbindet mehrere Clienten in einem Spiel. Er ist die zentrale Stelle und daf"ur zust"andig Spielzustands"anderungen durch Aufrufe des Clienten an den Server zu registrieren und darauf zu reagieren. Der Server implementiert die Schnittstellen IServer, IServerAuction und IServerTrade. Clienten können entweder direkt vom Server aus gestartet werden, oder "uber das Netzwerk Kontakt aufnehmen. In beiden F"allen passieren die meisten Interaktionen "uber IServer.


\subsubsection{Interfaces}
\begin{itemize}
%IServer
\item IServer
%IServerTrade
\item IServerTrade
%IServerAuction
\item IServerAuction
%ServerToNetwork?
%\item ServerToNetwork
\end{itemize}

\subsubsection{Klassen}
\begin{itemize}
\item MyServer 
\begin{itemize}
\item Implementiert IServer, IServerTrade, IServerAuction
\item Behandelt alle Spielstatusänderungen
\item Clienten können sowohl direkt als auch über das Netzwerk angeschlossen werden
\item Kann über die Konsole angesprochen werden
\item Attribute
\begin{itemize}
\item Ruleset ruleset
\item GameState gamestate
\item Network network
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean startGame(int playerCount) 
\item boolean loadGame(string path)
\item storeGame(int path)
\item loadSettings(int path)
\\l"adt die serverseitigen Einstellungen, zB welches Ruleset verwendet werden soll
\item boolean stopGame()
\\beendet das Spiel, speichert den Spielstand und trennt die Clienten
\item boolean startAIGames(int clientCount, int loops, string path)
\\Startet mehrere aufeinanderfolgende Spiele mit mehreren KI-Clienten. Das Ergebnis wird als Datei gespeichert
\end{itemize}
\end{itemize}
\end{itemize}

\subsection{Netzwerk}
Das Netzwerk stellt die Verbindung zwischen dem Client und dem Server dar, dabei ist es m"oglich das sich die Spieler in einem lokalen
Netzwerk befinden als auch "uber das Internet in einer anderen Java Virtual Machine arbeiten und am Spiel teilnehmen. Damit der Client Anfragen an den Server schicken kann, die die Ausf"uhrung von Methoden und die R"uckgabe von Ergebnissen beinhalten, verwenden wir den RMI (Remote Method Invocation) Mechanismus , der uns das entfernte Aufrufen von Methoden erlaubt. Die Verbindung von Client und Server wird durch Stellvertreterobjekte(engl. proxies) realisiert. Auf Seite des Clients wird ein Stellvertreter (Stub) des entfernten Objekts (Skeleton) erzeugt, welcher die Daten die "ubermittelt werden kapselt und diese in Form von Nachrichten an den Server "ubermittelt. Die Daten beinhalten unteranderem die zu ausf"uhrende Methode inklusive R"uckgabetyp und alle Parameter. Durch den RMI-Compiler ist es m"oglich die ben"otigten Stubs und Skeletons zu erzeugen. Damit von au"sen keine unberechtigten Zugriffe auf den Server erfolgen, werden Regeln in einer lokal zug"anglichen Datei erstellt und vom RMI Security Manager verwaltet.    
  
\subsubsection{Interfaces}
\begin{itemize}
%Remote
\item Remote
\item NetOjim
\begin{itemize}
\item erweitert das IServer interface 
\item Hier werden alle Methoden zur Verf"ugung gestellt, die das Server Objekt auf Seite des Clienten aufrufen kann
\end{itemize}
\item Serializable
\end{itemize}
\subsubsection{Klassen}


\begin{itemize}
\item UnicastRemoteObject
\begin{itemize}
\item Registriert das zu fernaufrufende Objekt bei der RMI Verwaltung
\item verwaltet die "Ubertragung des zu fernaufrufenden Objekts zur Java Virtual Machine des Clients.
\end{itemize}
\item ImplBuffer
\begin{itemize}
\item erweitert die Klasse UnicastRemoteObject
\item implementiert das Interface IServer
\item implementiert das Interface Serializable
\\Um das komplette Objekt als Parameter f"ur die RMI-Aufrufe zu "ubertragen benutzen wir Object Serialization 
\end{itemize}
\item BufferServer
\begin{itemize}
\item Verwaltet das Remote Objekt das f"ur den Clienten bereit steht  
\end{itemize}
\begin {itemize}
\item Methoden
\begin{itemize}
\item createBufferServer()
\\Meldet das Remote Objekt bei der RMI Registry an und sorgt daf"ur das dieses "uber das Netzwerk unter einen bestimmten Namen ansprechbar ist
\end{itemize}
\end{itemize}
\item Socket
\begin{itemize}
\item Stellt die Steckverbindung zum Netzwerk f"ur den Clienten dar
\end{itemize}
\item ServerSocket
\begin{itemize}
\item Stellt die Steckverbindung zum Netzwerk f"ur den Server dar
\end{itemize}
\item Network
\begin{itemize}
\item Verwaltet das Netzwerk
\end{itemize}
\begin {itemize}
\item Attribute
\begin{itemize}
\item ServerSocket server
\item Socket client
\item List $<$ClientDetails$>$ client
\end{itemize}
\item Methoden
\begin{itemize}
\item Network(ServerSocket server,Socket client, ServerDetails details) 
\item boolean waitingForClients()
\\Wartet bis alle Clienten mit dem Server verbunden sind
\item boolean cut (int playerID)
\\Trennt die Verbindung eines Clienten zum Server
\item boolean cut (int playerID, string message)
\\Trennt die Verbindung eines Clienten zum Server und schickt dem Clienten eine Nachricht
\item boolean connectionLost(int playerID)
\\"Uberpr"uft ob die Verbindung zu einem Clienten unterbrochen ist
\item boolean sendIServer(OjimServer server)
\\"Uberreicht dem Clienten ein IServer Objekt
\item ServerDetails getServerDetails()
\item addClient(ClientDetails client)
\\F"ugt einen Clienten zum Server hinzu
\end{itemize}
\end{itemize}
\item ServerDetails
\begin{itemize}
\item Verwaltet die Eigenschaften eines Servers
\end{itemize}
\begin {itemize}
\item Attribute
\begin{itemize}
\item String name
\item String ip
\item int connectedPlayers
\item int maxPlayers
\item boolean open
\item int port
\end{itemize}
\item Methoden
\begin{itemize}
\item ServerDetails(String name, String ip,int connectedPlayers, int maxPlayers,boolean open, int port ) 
\end{itemize}
\end{itemize}
\item ClientDetails
\begin{itemize}
\item Verwaltet die Eigenschaften eines Clienten
\end{itemize}
\begin {itemize}
\item Attribute
\begin{itemize}
\item String ip
\item String username
\end{itemize}
\item Methoden
\begin{itemize}
\item ClientDetails(String ip, String username) 
\end{itemize}
\end{itemize}
\item ClientConnection
\begin{itemize}
\item Verwaltet die aktive Verbindung zwischen Client und Server
\end{itemize}
\begin {itemize}
\item Attribute
\begin{itemize}
\item Socket clientSocket
\end{itemize}
\item Methoden
\begin{itemize}
\item boolean isConnected()
\\"Uberpr"uft ob der Client mit dem Server verbunden ist
\item connect(String ip, int port)
\\Verbindet den Clienten mit dem Server
\item disconnect() 
\\Unterbricht die Verbindung des Clienten zum Server
\end{itemize}
\end{itemize}
\item BufferClient
\begin{itemize}
\item Client sucht das Server Objekt beim Namendienst 
\begin {itemize}
\item Methoden
\begin{itemize}
\item registerClient() 
\end{itemize}
\end{itemize}
\end{itemize}
\end{itemize}

\section{Beschreibung der zentralen Abläufe}
\section{Weitere Entwurfdetails}
\subsection{Kompatibilität mit Client und Server der anderen Gruppe}
Während der Entwurfsphase fanden mehrere Treffen mit einem Verantwortlichen der anderen Gruppe statt. Im Vorfeld wurde versucht, Punkte, an denen es Missverständnisse geben könnte, zu identifizieren. Im Zuge dessen wurden die vorgegebenen Interfaces erweitert und verändert, ein eigenes Interface für den Client definiert. Obwohl beide Gruppen unterschiedliche Entwurfsansätze verfolgen, sollte zumindest nach jetzigem Kenntnisstand einer erfolgreichen Kommunikation nichts im Wege stehen. Beim Abstimmungsprozess wurden zugunsten der Kompatibilität Einschränkungen bei der Erweiterbarkeit hingenommen.
\section{Abweichungen vom Pflichtenheft}
% besserer Name?
\begin{itemize}
\item Im Pflichtenheft wurde beschrieben dass der Server alle vom Clienten einkommenden Nachrichten/Befehle "uberpr"uft, ob diese auch vom richtigen Clienten kommen, so dass es nicht m"oglich ist sich als "falscher" Client auszugeben. Da dies allerdings nicht gefordert war/ist, wurde dies nicht modelliert. Da die Validierung als recht eigenst"andige Schicht zwischen Server-Netzwerkanschluss und Server-Spiellogik liegen sollte, ist es problemlos m"ogloch, diese zus"atzliche Schicht auszulassen. Das hei"st es ergeben sich abseits der Validierung keine "Anderungen an Architektur und Design.
\item Nach Besprechungen innerhalb unserer Gruppe und gemeinsam mit der anderen Gruppe wurde beschlossen, den Nachrichtenflu"s zwischen Clienten und Server so umzugestalten, dass der Server nun statt passiv Anfragen der Clienten zu bearbeiten, sondern auch aktiv Benachrichtigungen an dieselben zu schicken. F"ur diesen Zweck wurde zusammen mit der anderen Gruppe die Schnittstelle IClient konzipiert, die auf "ahnliche Weise wie IServer funktionieren soll, d.h. die meisten Methoden der Schnittstelle IServer haben ein entgegengesetztes "Aquivalent in der Schnittstelle IClient
\item Da bei beiden Monopoly-Gruppen das Spiel lokalisierbar sein soll und trotzdem Bereiche des Spielbretts/Spielfelds variabel gestaltet werden sollen, werden Stra"sennamen und "ahnliches vom Server in lokalisierter Fassung bereitgestellt. Dies f"uhrt aber auch dazu, dass anders als im Pflichtenheft der Spielplan nicht beim Clienten abgespeichert wird, sondern beim Server. Am Anfang eines Spieles, oder bei Bedarf, besorgt sich der Client vom Server alle f"ur ihn relevanten Daten als lokalisierten Text.
\item Im Pflichtenheft wurde vorgesehen, dass auch die Clienten den Spielstand speichern k"onnen. Da dies aber wegen m"oglicherweise inkonsistenten Zust"anden und mangelnder Kompatibilität viel Zusatzarbeit bedeuten w"urde, wurde darauf verzichtet. Der Spielzustand wird also nur vom Server vollst"andig gespeichert, Clienten werden zwar "uber "Anderungen daran informiert, aber haben keinen Bedarf mehr daran, dies l"angerfristig zu speichern.
\item Im Pflichtenheft ist eine Spielspezifische maximale Spieleranzahl nicht vorgesehen, aus Gr"unden der Einfachheit wurde diese aber eingef"uhrt. Ein Spiel startet nun, wenn sich die maximale Anzahl von Clienten im Wartezustand befinden. Dies f"uhrt zu einer Reduzierung des Warteraums, es ist dort nicht mehr m"oglich, sich selbst als "Zum Spielen bereit" zu setzen, was auch Probleme mit der Kompatibilit"at des Servers der anderen Gruppe verhindern sollte.
\item Ebenfalls verzichtet wurde auf die M"oglichkeit, ein Spiel aktiv aufzugeben und trotzdem weiterhin zuzuschauen.
\item Im Pflichtenheft war es nur vorgesehen, dass ein AIClient von au"serhalb des Servers Zugriff auf das Spiel hat. Das hei"st ein AIClient m"usste als eigenes Programm gestartet werden und sich dann auf den Server verbinden. Es ist nun aber auch m"oglich, direkt vom Server aus einen solchen Clienten dem Spiel hinzuzuf"ugen.
\item Es ist nicht möglich einem angefangenen Spiel (wieder) beizutreten
\item 
\item /F11160/ "`Spielstand laden"' und /F11170/ "`Spielstand speichern"' wurden fallengelassen 
\end{itemize}
\section{Verantwortlichkeiten und weitere Planungen}
Die Leitung der einzelnen Abschnitte wird von folgenden Personen übernommen und vorgestellt:
\begin{description}
% Nennen?
\item[Pflichtenheft] Philip Caroli
% Nennen?
\item[Entwurf] Fabian Neundorf
\item[Implementierung] Jeremias Mechler
\item[Validierung] Usman Ghani Ahmed
\item[Präsentation] Maximilian Madlung
\end{description}
Zusätzlich übernimmt Fabian Neundorf die Kommunikation mit der anderen Gruppe und stimmt sich mit den Verantwortlichen ab.

GANTT DIAGRAMM HIER!
%\includegraphics[height=2cm]{Gantt/gantt}
\section{Klassendiagramm}
Das Klassendiagramm befindet sich als \textit{pdf}-Datei in "`class\_diagram.pdf"'.
\section{Weitere Informationen}
Ein Teil der Beschreibungen der Methoden IServer, IServerTrade und IServerAuction stammen von Daniel Bruns.
\end{document}

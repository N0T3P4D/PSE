\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb}
\usepackage{enumerate}
\usepackage{ngerman}
%\usepackage{graphicx}
\usepackage{ifpdf}
\usepackage[usenames]{color}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
\usepackage[titles]{tocloft}
\usepackage[colorlinks=true,linkcolor=black]{hyperref}
\usepackage[pdftex]{graphicx}
\usepackage{geometry}
%\geometry{top=0cm,bottom=0cm,left=0cm,right=0cm,nohead,nofoot}


\title{Entwurf}
\date{}

\author{Usman Ghani Ahmed \\
Philip Caroli\\
Maximilian Madlung\\ 
Jeremias Mechler\\ 
Fabian Neundorf}

\ifpdf
\DeclareGraphicsExtensions{.pdf,.png}
\else
\DeclareGraphicsExtensions{.eps}
\fi

% Einr√ºckung bei Abs√§tzen
\setlength{\parindent}{0mm}
% Zeilenabstand bei Abs√§tzen
\setlength{\parskip}{2mm}

\begin{document}
 
\vspace{5cm}
\maketitle
\begin{center}
\vspace{3cm}
\huge{Praxis der Softwareentwicklung \\
Gruppe 3 \\[0.5cm]
Entwicklung eines "`Monopoly"'-√§hnlichen Spiels \\[0.5cm]
%\includegraphics[height=2cm]{kitlogo_de_rgb}  \\[0.5cm]
WS 2010 / 2011} \\[2cm]
Version 1.1
%\textcolor{red}{! DRAFT !}
\end{center}

\newpage

\tableofcontents

\newpage

\section{KI-Client}

\subsection{Allgemeines}
Feature X ist wegen ... noch nicht voll funktionsf√§hig
\subsection{Bekannte Fehler / Probleme}
\subsection{√Ñnderungen gegen√ºber dem Entwurf}
\subsection{Entwurfsentscheidungen}

\section OjimServer
\subsection{Allgemeines}
\subsection {√Ñnderungen gegen√ºber dem Entwurf}
\begin{itemize}
\item Der Server beinhaltet nun eine M√∂glichkeit ihn √ºber die Kommandozeile zu starten und zu beenden
\item Der Server bekommt am Anfang die maximale Spielerzahl und die Computerspielerzahl √ºbergeben
\item Die Funktionalit√§t der Methoden aus IServer, IServerTrade und IServerAuction werden wie im Entwurf vorgesehen implementiert, einzelne Abl√§ufe und Folgeaktionen waren im Entwurf aber nicht genau vorgeschrieben.
\item Der √úbersichtlichkeit halber wurden einige privaten Methoden eingef√ºgt, beispielsweise
\begin{itemize}
\item private boolean checkAllPlayersReady()
\end{itemize}
\item Es gab ein paar Namens‰nderungen im package org.ojim.rmi.server 
\begin{itemize}
\item BufferServer wurde ge‰ndert in StartNetOjim
\item ImplBuffer wurde ge‰ndert in ImplNetOjim
\end{itemize}
\item Network Klasse wurde weggelassen, da die RMI die Verbingsschicht ¸berdeckt und die Sockets selber managt
\item Da der Server auch in der Lage sein muss entfernte Methoden in den Clients aufzurufen, sind wir auf Callbacks angewiesen Zu diesem Zweck sind noch folgende Klassen hinzugekommen , die f¸r den Server Methoden zur Verf¸gung stellen welche aus einer anderen JVM aufgerufen werden kˆnnen
\begin{itemize}
\item interface NetClient extends Remote : spezifiziert alle Methoden die ¸ber das Netzwerk vom Server aufgerufen werden kˆnnen 
\item ImplNetClient extends UnicastRemoteObject implements NetOjim: implementiert die Methoden des Interfaces
\item StartNetClient Startet einen neuen Client und holt sich eine Referenz vom Namendienst der im Server gestartet wurde
\end{itemize}

\section{ClientBase}
\subsection {√Ñnderungen gegen√ºber dem Entwurf}
\subsubsection{SimpleClient}
Da der KI Client verschiedene "Command"-Klassen hat, ben√∂tigen diese Zugriff auf den IServer ohne sich selber als neuen Client einzuloggen. Deshalb wurde eine vereinfachte Client Klasse geschrieben. Von dieser k√∂nnen dann alle Command Klassen des KI Clients, sowie ClientBase erben.

Die Klasse SimpleClient dabei implementiert nicht das IClient Interface, um eben zu verhindern, dass sie doppelt registiert werden m√ºssen. Sie implementiert dabei nur Methoden um die IServer-Methoden abgesichert aufzurufen. Die Getter-Methoden werden dabei direkt durchgeleitet. Alle Aktionsmethoden hingegen testen vorher, ob es nach den Spielregeln erlaubt ist, diesen Zug durchzuf√ºhren.
\subsubsection{inform*-Methoden}
Alle inform*-Methoden sind jetzt final und rufen die abstrakten on*-Methoden auf. Dadurch wird gew√§hrleistet, dass diese Methoden auf jeden Fall ausgef√ºhrt werden. Somit m√ºssen alle Clients, die nicht abstrakt sind, diese Methoden zwingend Implementieren.

Damit ist ClientBase so √§hnlich wie aufgebaut, wie die Listener Interfaces aus Swing. Nebenbei √ºbersetzt sie die Variablen in die entsprechenden Objekte aus dem GameState.

\section{Logik}
Zu Beachten ist, dass auf dem Spielfeld, es mehrere "Felder" gibt. Das hei√üt wenn im folgenden von "Feld" ausgegangen wird, dann handelt es sich normalerweise um diese Einzelfelder (z.~B. Stra√üen, Bahnh√∂fe, \dots).
\subsection {√Ñnderungen gegen√ºber dem Entwurf}
\subsubsection{Stra√üengruppen}
Zus√§tzlich zur normalen Stra√üengruppe (eigentlich Feldergruppe) gibt es weitere spezieller Feldgruppen.

So gibt es die Bahnhofsgruppe, in der mehrere Bahnh√∂fe gespeichert werden. Damit kann der Bahnhof selber √ºberpr√ºfen, anhand der Gruppe in der der Bahnhof ist, wie viele weitere Bahnh√∂fe der Besitzer des testenden Bahnhofs hat. Diese Gruppe speichert dann auch, wie teuer die Miete f√ºr diesen Bahnhof ist. Somit kann man sehr einfach die Anzahl der Bahnh√∂fe √§ndern.

Zus√§tzlich gibt es noch eine Feldergruppe f√ºr Infrastrukturgeb√§ude. Hier verh√§lt es sich regeltechnisch √§hnlich wie bei den Bahnh√∂fen. Da dort abh√§ngig von den besitzten Feldern der Faktor sich ver√§ndert. Nun √ºberpr√ºft auch dieses Feld, wie viele der Besitzer besitzt und fragt dann bei der Gruppe ab, wie gro√ü der Faktor daf√ºr ist. Dadurch kann man einfach ein neues Infrastrukturgeb√§ude der Gruppe hinzuf√ºgen und die Faktoren ver√§ndern.
\subsubsection{ServerGameState}
Der ServerGameState dient auf der Serverseite dazu die besonderen Daten f√ºr das Spielbrett zu speichern. So werden die Karten nicht auf dem Client gespeichert, da die gemeinsame Schnittstelle das anbietet.

Au√üerdem definiert sie ein Gef√§ngnis, in dass die Spieler kommen, nachdem man zu oft ein Pasch gew√ºrfel hat.

\subsubsection{ServerPlayer}
Zus√§tzlich wurde die Klasse ServerPlayer hinzugef√ºgt die Serverspezifische Dinge speichert. Das w√§re einseits die eigenen Karten, da diese modular ausgelegt sind. Da diese aber nur auf den Server gespeichert sind -- da die Kommunikation es nicht erlaubt die Karten auszutauschen -- werden sie in dieser Klasse gespeichert.

Au√üerdem speichert diese Klasse eine Referenz auf den IClient, damit dessen inform*-Methoden aufgerufen werden k√∂nnen.

\subsubsection{Weitere √Ñnderungen}
\begin{itemize}
\item Da FieldRule und CardRule keinen Zweck erf√ºllt, wurde diese in Card und Field sowie dessen Unterklassen √ºbernommen.
\item Einige Actions wurden entfernt und einige andere hinzugef√ºgt.
\item Mithilfe der ActionFactory k√∂nnen einige vordefinierte Actions erzeugen.
\item Da die normale Logik nur die Werte √§ndert, √ºbernimmt die Klasse ServerLogic das Informieren der einzelnen Clients.
\item Zus√§tzlich wurden als Gimick "Dice" und "DiceSet" hinzugef√ºgt.
\end{itemize}

\end{document}
